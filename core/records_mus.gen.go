// Code generated by musgen-go. DO NOT EDIT.

package core

import (
	"github.com/mus-format/mus-go/ord"
	"github.com/mus-format/mus-go/raw"
	"github.com/mus-format/mus-go/varint"
)

var (
	mapΔE1Bqt5IiUfWigYWI0iLeAΞΞ   = ord.NewMapSer[string, string](ord.String, ord.String)
	sliceaΔ7Tr04CnuL9w2IzwpltxQΞΞ = ord.NewSliceSer[float32](varint.Float32)
	slicefG2f4bvTWd6xUnfUsQ4txgΞΞ = ord.NewSliceSer[ConceptRef](ConceptRefMUS)
)

var SpeakerTypeMUS = speakerTypeMUS{}

type speakerTypeMUS struct{}

func (s speakerTypeMUS) Marshal(v SpeakerType, bs []byte) (n int) {
	return varint.Int.Marshal(int(v), bs)
}

func (s speakerTypeMUS) Unmarshal(bs []byte) (v SpeakerType, n int, err error) {
	tmp, n, err := varint.Int.Unmarshal(bs)
	if err != nil {
		return
	}
	v = SpeakerType(tmp)
	return
}

func (s speakerTypeMUS) Size(v SpeakerType) (size int) {
	return varint.Int.Size(int(v))
}

func (s speakerTypeMUS) Skip(bs []byte) (n int, err error) {
	return varint.Int.Skip(bs)
}

var IDMUS = iDMUS{}

type iDMUS struct{}

func (s iDMUS) Marshal(v ID, bs []byte) (n int) {
	return varint.Uint64.Marshal(uint64(v), bs)
}

func (s iDMUS) Unmarshal(bs []byte) (v ID, n int, err error) {
	tmp, n, err := varint.Uint64.Unmarshal(bs)
	if err != nil {
		return
	}
	v = ID(tmp)
	return
}

func (s iDMUS) Size(v ID) (size int) {
	return varint.Uint64.Size(uint64(v))
}

func (s iDMUS) Skip(bs []byte) (n int, err error) {
	return varint.Uint64.Skip(bs)
}

var ChatRecordMUS = chatRecordMUS{}

type chatRecordMUS struct{}

func (s chatRecordMUS) Marshal(v ChatRecord, bs []byte) (n int) {
	n = IDMUS.Marshal(v.Id, bs)
	n += SpeakerTypeMUS.Marshal(v.Speaker, bs[n:])
	n += ord.String.Marshal(v.Contents, bs[n:])
	n += raw.TimeUnixMicro.Marshal(v.Timestamp, bs[n:])
	n += raw.TimeUnixMicro.Marshal(v.InsertedAt, bs[n:])
	n += raw.TimeUnixMicro.Marshal(v.UpdatedAt, bs[n:])
	n += slicefG2f4bvTWd6xUnfUsQ4txgΞΞ.Marshal(v.Concepts, bs[n:])
	n += sliceaΔ7Tr04CnuL9w2IzwpltxQΞΞ.Marshal(v.Vector, bs[n:])
	return n + mapΔE1Bqt5IiUfWigYWI0iLeAΞΞ.Marshal(v.Metadata, bs[n:])
}

func (s chatRecordMUS) Unmarshal(bs []byte) (v ChatRecord, n int, err error) {
	v.Id, n, err = IDMUS.Unmarshal(bs)
	if err != nil {
		return
	}
	var n1 int
	v.Speaker, n1, err = SpeakerTypeMUS.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Contents, n1, err = ord.String.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Timestamp, n1, err = raw.TimeUnixMicro.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.InsertedAt, n1, err = raw.TimeUnixMicro.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.UpdatedAt, n1, err = raw.TimeUnixMicro.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Concepts, n1, err = slicefG2f4bvTWd6xUnfUsQ4txgΞΞ.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Vector, n1, err = sliceaΔ7Tr04CnuL9w2IzwpltxQΞΞ.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Metadata, n1, err = mapΔE1Bqt5IiUfWigYWI0iLeAΞΞ.Unmarshal(bs[n:])
	n += n1
	return
}

func (s chatRecordMUS) Size(v ChatRecord) (size int) {
	size = IDMUS.Size(v.Id)
	size += SpeakerTypeMUS.Size(v.Speaker)
	size += ord.String.Size(v.Contents)
	size += raw.TimeUnixMicro.Size(v.Timestamp)
	size += raw.TimeUnixMicro.Size(v.InsertedAt)
	size += raw.TimeUnixMicro.Size(v.UpdatedAt)
	size += slicefG2f4bvTWd6xUnfUsQ4txgΞΞ.Size(v.Concepts)
	size += sliceaΔ7Tr04CnuL9w2IzwpltxQΞΞ.Size(v.Vector)
	return size + mapΔE1Bqt5IiUfWigYWI0iLeAΞΞ.Size(v.Metadata)
}

func (s chatRecordMUS) Skip(bs []byte) (n int, err error) {
	n, err = IDMUS.Skip(bs)
	if err != nil {
		return
	}
	var n1 int
	n1, err = SpeakerTypeMUS.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = ord.String.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = raw.TimeUnixMicro.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = raw.TimeUnixMicro.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = raw.TimeUnixMicro.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = slicefG2f4bvTWd6xUnfUsQ4txgΞΞ.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = sliceaΔ7Tr04CnuL9w2IzwpltxQΞΞ.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = mapΔE1Bqt5IiUfWigYWI0iLeAΞΞ.Skip(bs[n:])
	n += n1
	return
}

var ConceptMUS = conceptMUS{}

type conceptMUS struct{}

func (s conceptMUS) Marshal(v Concept, bs []byte) (n int) {
	n = IDMUS.Marshal(v.Id, bs)
	n += ord.String.Marshal(v.Name, bs[n:])
	n += ord.String.Marshal(v.Type, bs[n:])
	n += sliceaΔ7Tr04CnuL9w2IzwpltxQΞΞ.Marshal(v.Vector, bs[n:])
	n += raw.TimeUnixMicro.Marshal(v.InsertedAt, bs[n:])
	return n + raw.TimeUnixMicro.Marshal(v.UpdatedAt, bs[n:])
}

func (s conceptMUS) Unmarshal(bs []byte) (v Concept, n int, err error) {
	v.Id, n, err = IDMUS.Unmarshal(bs)
	if err != nil {
		return
	}
	var n1 int
	v.Name, n1, err = ord.String.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Type, n1, err = ord.String.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Vector, n1, err = sliceaΔ7Tr04CnuL9w2IzwpltxQΞΞ.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.InsertedAt, n1, err = raw.TimeUnixMicro.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.UpdatedAt, n1, err = raw.TimeUnixMicro.Unmarshal(bs[n:])
	n += n1
	return
}

func (s conceptMUS) Size(v Concept) (size int) {
	size = IDMUS.Size(v.Id)
	size += ord.String.Size(v.Name)
	size += ord.String.Size(v.Type)
	size += sliceaΔ7Tr04CnuL9w2IzwpltxQΞΞ.Size(v.Vector)
	size += raw.TimeUnixMicro.Size(v.InsertedAt)
	return size + raw.TimeUnixMicro.Size(v.UpdatedAt)
}

func (s conceptMUS) Skip(bs []byte) (n int, err error) {
	n, err = IDMUS.Skip(bs)
	if err != nil {
		return
	}
	var n1 int
	n1, err = ord.String.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = ord.String.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = sliceaΔ7Tr04CnuL9w2IzwpltxQΞΞ.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = raw.TimeUnixMicro.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = raw.TimeUnixMicro.Skip(bs[n:])
	n += n1
	return
}

var ConceptRefMUS = conceptRefMUS{}

type conceptRefMUS struct{}

func (s conceptRefMUS) Marshal(v ConceptRef, bs []byte) (n int) {
	n = IDMUS.Marshal(v.ConceptId, bs)
	return n + varint.Int.Marshal(v.Importance, bs[n:])
}

func (s conceptRefMUS) Unmarshal(bs []byte) (v ConceptRef, n int, err error) {
	v.ConceptId, n, err = IDMUS.Unmarshal(bs)
	if err != nil {
		return
	}
	var n1 int
	v.Importance, n1, err = varint.Int.Unmarshal(bs[n:])
	n += n1
	return
}

func (s conceptRefMUS) Size(v ConceptRef) (size int) {
	size = IDMUS.Size(v.ConceptId)
	return size + varint.Int.Size(v.Importance)
}

func (s conceptRefMUS) Skip(bs []byte) (n int, err error) {
	n, err = IDMUS.Skip(bs)
	if err != nil {
		return
	}
	var n1 int
	n1, err = varint.Int.Skip(bs[n:])
	n += n1
	return
}

var CheckpointMUS = checkpointMUS{}

type checkpointMUS struct{}

func (s checkpointMUS) Marshal(v Checkpoint, bs []byte) (n int) {
	n = ord.String.Marshal(v.ProcessorType, bs)
	n += IDMUS.Marshal(v.LastID, bs[n:])
	return n + raw.TimeUnixMicro.Marshal(v.UpdatedAt, bs[n:])
}

func (s checkpointMUS) Unmarshal(bs []byte) (v Checkpoint, n int, err error) {
	v.ProcessorType, n, err = ord.String.Unmarshal(bs)
	if err != nil {
		return
	}
	var n1 int
	v.LastID, n1, err = IDMUS.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.UpdatedAt, n1, err = raw.TimeUnixMicro.Unmarshal(bs[n:])
	n += n1
	return
}

func (s checkpointMUS) Size(v Checkpoint) (size int) {
	size = ord.String.Size(v.ProcessorType)
	size += IDMUS.Size(v.LastID)
	return size + raw.TimeUnixMicro.Size(v.UpdatedAt)
}

func (s checkpointMUS) Skip(bs []byte) (n int, err error) {
	n, err = ord.String.Skip(bs)
	if err != nil {
		return
	}
	var n1 int
	n1, err = IDMUS.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = raw.TimeUnixMicro.Skip(bs[n:])
	n += n1
	return
}
